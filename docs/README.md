Сейчас в процессе опробирования взаимодействие через веб-сокеты.

Общая схема взаимодействия:

```
                _______________________        ____________________________
Browser1 <---->|    reactphp-pusher    |      |        battle-sea app      |
               | WS->hanlde-> ZMQ_PUSH------->| ZMQ_PULL-> listen and route| 
Browser2 <---->| WS<-hanlde<- ZMQ_PULL |<-------ZMQ_PUSH<- send from app   |
                ------------------------       ----------------------------
```

Для обслуживания веб-сокетов используется проект reactphp-pusher.
В проекте есть SocketConnectionsManager, который по факту становится полноценным приёмником и рассыльщиком сообщений.

Для того чтобы это корректно работало:
- В ZMQ поднимаем два канала: от сокетов в сервер (toServer) и от сервера в сокеты (toClient).
- PUSH в Publisher сейчас корректно обрабатывает ситуацию как адресной рассылки так и общей. 
- Для адресной рассылки нужно использовать ID получателя: это userID в том или ином виде. Лучше - хешированый, чтобы избежать подбора в будущем.

- PUBLISH с клиентов сейчас подхватывается и перебрасывается в ZMQ, на стороне приложения есть 
прототип PullMessagesListener (и команда messages:pull-listener для его запуска), который и слушает нужный канал в ZMQ.

TODO:
- роутинг входящих в Listener сообщений, в зависимости от типа. Этого будет достаточно 
для разработки корректного прототипа работы приложения через сокеты. При необходимости ZMQ можно будет заменить на любую
другую очередь (rabbit, beanstalkd, ??)
- можно входящие сообщения роутить выбрасыванием соответствующего dispatch. Тогда нужно использовать queue для задач.
Тут как раз развязывание основного обработчика ZMQ сообщений и исполнения нужных контроллеров.

